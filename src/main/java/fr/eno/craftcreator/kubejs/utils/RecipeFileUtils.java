package fr.eno.craftcreator.kubejs.utils;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import com.google.gson.*;
import fr.eno.craftcreator.kubejs.KubeJSManager;
import fr.eno.craftcreator.kubejs.jsserializers.ModRecipesJSSerializer;
import fr.eno.craftcreator.utils.ModifiedRecipe;
import fr.eno.craftcreator.utils.PairValue;
import io.netty.buffer.Unpooled;
import net.minecraft.inventory.IInventory;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.item.crafting.IRecipe;
import net.minecraft.item.crafting.IRecipeSerializer;
import net.minecraft.item.crafting.IRecipeType;
import net.minecraft.item.crafting.Ingredient;
import net.minecraft.network.PacketBuffer;
import net.minecraft.util.NonNullList;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.registry.Registry;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.StringTextComponent;
import net.minecraft.util.text.TextFormatting;
import net.minecraftforge.registries.ForgeRegistries;
import vazkii.botania.api.BotaniaAPI;
import vazkii.botania.api.recipe.*;
import vazkii.botania.common.crafting.StateIngredientTag;
import vazkii.botania.common.item.ModItems;
import vazkii.botania.common.item.brew.ItemVial;

import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@SuppressWarnings("unchecked")
public class RecipeFileUtils
{
    private static final Pattern RECIPE_PATTERN = Pattern.compile("(?<=\\()(.*?)(?=\\))");

    public final static String ADD_RECIPE_START = "ADDED-RECIPES-START";
    public final static String MODIFIED_RECIPE_START = "REMOVED-RECIPES-START";

    private static final List<String> MODIFIED_START_PATTERNS = Arrays.asList("event.remove", "event.replaceInput", "event.replaceOutput");

    private static final Gson GSON = new GsonBuilder().setLenient().create();

    private static final List<String> comps = Arrays.asList("Output", "Input", "Mod", "Type", "Id");

    public static File getRecipeFile(String modId)
    {
        File recipe = new File(KubeJSManager.getInstance().getKubeJSRecipesFolder(), modId + ".js");

        if(!recipe.exists() || recipe.length() <= 0L)
        {
            try
            {
                recipe.createNewFile();

                List<String> lines = Arrays.asList("// AUTO-GENERATED by Craft Creator", "onEvent('recipes', event => {", "", "\t// " + MODIFIED_RECIPE_START, "", "\t// " + ADD_RECIPE_START, "", "})");

                Files.write(recipe.toPath(), lines, StandardCharsets.UTF_8);
            }
            catch(IOException e)
            {
                e.printStackTrace();
            }
        }

        return recipe;
    }

    public static <T extends IRecipe<?>> List<T> getAddedRecipesFor(String modId, IRecipeType<T> recipeType)
    {
        List<T> recipes = new ArrayList<>();

        IRecipeSerializer<T> serializer = (IRecipeSerializer<T>) ForgeRegistries.RECIPE_SERIALIZERS.getValue(getName(recipeType));

        try
        {
            File recipeFile = RecipeFileUtils.getRecipeFile(modId);

            checkTypeGroup(recipeFile, recipeType);

            boolean isCraftingTableCraft = getName(recipeType).toString().contains("minecraft:crafting");

            List<String> lines = Files.readAllLines(recipeFile.toPath(), StandardCharsets.UTF_8);

            for(String line : lines)
                if((line.contains(getName(recipeType).toString()) || isCraftingTableCraft) && line.contains("event.custom"))
                {
                    Matcher JSON_MATCHER = RECIPE_PATTERN.matcher(line);

                    if(JSON_MATCHER.find())
                    {
                        if(isCraftingTableCraft)
                        {
                            JsonObject jsonObject = GSON.fromJson(new StringReader(JSON_MATCHER.group()), JsonObject.class);
                            IRecipeSerializer<T> craftingTableSerializer = (IRecipeSerializer<T>) ForgeRegistries.RECIPE_SERIALIZERS.getValue(new ResourceLocation(jsonObject.get("type").getAsString()));
                            T tempRecipe = craftingTableSerializer.read(new ResourceLocation(modId, "recipe"), jsonObject);
                            T recipe = craftingTableSerializer.read(new ResourceLocation(modId, getOutput(tempRecipe).values().stream().findAny().orElse(null).getPath()), jsonObject);
                            recipes.add(recipe);
                            continue;
                        }

                        JsonObject jsonObject = GSON.fromJson(new StringReader(JSON_MATCHER.group()), JsonObject.class);
                        T tempRecipe = serializer.read(new ResourceLocation(modId, "recipe"), jsonObject);
                        T recipe = serializer.read(new ResourceLocation(modId, getOutput(tempRecipe).values().stream().findAny().orElse(null).getPath()), jsonObject);
                        recipes.add(recipe);
                    }
                }
        }
        catch(IOException e)
        {
            e.printStackTrace();
        }

        return recipes;
    }

    public static <C extends IInventory, T extends IRecipe<C>> void removeAddedRecipe(T addedRecipe, String modId)
    {
        IRecipeType<T> recipeType = (IRecipeType<T>) addedRecipe.getType();
        IRecipeSerializer<T> serializer = (IRecipeSerializer<T>) ForgeRegistries.RECIPE_SERIALIZERS.getValue(getName(recipeType));

        try
        {
            File recipeFile = RecipeFileUtils.getRecipeFile(modId);

            checkTypeGroup(recipeFile, recipeType);
            boolean isCraftingTableCraft = getName(recipeType).toString().contains("minecraft:crafting");

            List<String> lines = Files.readAllLines(recipeFile.toPath(), StandardCharsets.UTF_8);

            int index = 0;
            for(String line : lines)
            {
                if(line.contains(getName(recipeType).toString()) && line.contains("event.custom"))
                {
                    Matcher JSON_MATCHER = RECIPE_PATTERN.matcher(line);

                    if(JSON_MATCHER.find())
                    {
                        JsonObject jsonObject = GSON.fromJson(new StringReader(JSON_MATCHER.group()), JsonObject.class);
                        T tempRecipe = null;
                        T recipe = null;
                        if(isCraftingTableCraft)
                        {
                            IRecipeSerializer<T> craftingTableSerializer = (IRecipeSerializer<T>) ForgeRegistries.RECIPE_SERIALIZERS.getValue(new ResourceLocation(jsonObject.get("type").getAsString()));
                            tempRecipe = craftingTableSerializer.read(new ResourceLocation(modId, "recipe"), jsonObject);
                            recipe = craftingTableSerializer.read(new ResourceLocation(modId, getOutput(tempRecipe).values().stream().findAny().orElse(null).getPath()), jsonObject);

                            PacketBuffer existingRecipeBuffer = new PacketBuffer(Unpooled.buffer());
                            PacketBuffer jsonRecipeBuffer = new PacketBuffer(Unpooled.buffer());
                            craftingTableSerializer.write(existingRecipeBuffer, addedRecipe);
                            craftingTableSerializer.write(jsonRecipeBuffer, recipe);

                            if(existingRecipeBuffer.compareTo(jsonRecipeBuffer) == 0)
                            {
                                lines.remove(index);
                                Files.write(recipeFile.toPath(), lines, StandardCharsets.UTF_8);
                                return;
                            }

                            continue;
                        }

                        tempRecipe = serializer.read(new ResourceLocation(modId, "recipe"), jsonObject);
                        recipe = serializer.read(new ResourceLocation(modId, getOutput(tempRecipe).values().stream().findAny().orElse(null).getPath()), jsonObject);

                        PacketBuffer existingRecipeBuffer = new PacketBuffer(Unpooled.buffer());
                        PacketBuffer jsonRecipeBuffer = new PacketBuffer(Unpooled.buffer());
                        serializer.write(existingRecipeBuffer, addedRecipe);
                        serializer.write(jsonRecipeBuffer, recipe);

                        if(existingRecipeBuffer.compareTo(jsonRecipeBuffer) == 0)
                        {
                            lines.remove(index);
                            Files.write(recipeFile.toPath(), lines, StandardCharsets.UTF_8);
                            return;
                        }
                    }
                }
                index++;
            }
        }
        catch(IOException e)
        {
            e.printStackTrace();
        }
    }

    public static <T extends IRecipe<?>> List<ModifiedRecipe> getModifiedRecipesFor()
    {
        List<ModifiedRecipe> modifiedRecipes = new ArrayList<>();

        for(String modId : SupportedMods.MODS_IDS)
        {
            try
            {
                File recipeFile = RecipeFileUtils.getRecipeFile(modId);
                List<String> lines = Files.readAllLines(recipeFile.toPath(), StandardCharsets.UTF_8);

                for(String line : lines)
                {
                    Optional<String> descriptor = MODIFIED_START_PATTERNS.stream().filter(line::contains).findAny();

                    if(descriptor.isPresent())
                    {
                        Matcher JSON_MATCHER = RECIPE_PATTERN.matcher(line);

                        if(JSON_MATCHER.find())
                        {
                            ModifiedRecipeType modifiedRecipeType = ModifiedRecipeType.byDescriptor(descriptor.get());
                            ModifiedRecipe modifiedRecipe = new ModifiedRecipe(modifiedRecipeType);
                            getModifiedRecipe(modifiedRecipe, JSON_MATCHER.group());
                            modifiedRecipes.add(modifiedRecipe);
                        }
                    }
                }
            }
            catch(IOException e)
            {
                e.printStackTrace();
            }
        }

        return modifiedRecipes;
    }

    public static void insertAndWriteLines(String modId, IRecipeType<?> recipeType, String line)
    {
        try
        {
            File recipeFile = RecipeFileUtils.getRecipeFile(modId);

            checkTypeGroup(recipeFile, recipeType);

            List<String> lines = Files.readAllLines(recipeFile.toPath(), StandardCharsets.UTF_8);

            if(lines.stream().anyMatch(lineFromLines -> lineFromLines.contains(line))) return;

            for(int i = 0; i < lines.size(); i++)
                if(lines.get(i).contains(getStartRecipeTypeGroup(recipeType)))
                {
                    if(lines.get(i).contains(line)) break;

                    lines.add(i + 1, "\t" + line);
                    break;
                }
            Files.write(recipeFile.toPath(), lines, StandardCharsets.UTF_8);
        }
        catch(IOException e)
        {
            e.printStackTrace();
        }
    }

    public static void insertAndWriteLinesToRemoveRecipe(String modId, String line)
    {
        try
        {
            File recipeFile = RecipeFileUtils.getRecipeFile(modId);

            List<String> lines = Files.readAllLines(recipeFile.toPath(), StandardCharsets.UTF_8);
            if(lines.contains(line)) return;

            for(int i = 0; i < lines.size(); i++)
                if(lines.get(i).contains(MODIFIED_RECIPE_START))
                {
                    if(lines.get(i).contains(line)) break;

                    lines.add(i + 1, "\t" + line);
                    break;
                }
            Files.write(recipeFile.toPath(), lines, StandardCharsets.UTF_8);
        }
        catch(IOException e)
        {
            e.printStackTrace();
        }
    }

    private static void checkTypeGroup(File recipeFile, IRecipeType<?> recipeType)
    {
        try
        {
            List<String> lines = Files.readAllLines(recipeFile.toPath(), StandardCharsets.UTF_8);

            boolean hasGroup = false;

            for(String line : lines)
                if(line.contains(getStartRecipeTypeGroup(recipeType)))
                {
                    hasGroup = true;
                    break;
                }

            if(!hasGroup)
            {
                for(int i = 0; i < lines.size(); i++)
                    if(lines.get(i).contains(ADD_RECIPE_START))
                    {
                        lines.add(i + 1, "\t// " + getStartRecipeTypeGroup(recipeType));
                        Files.write(recipeFile.toPath(), lines, StandardCharsets.UTF_8);
                        break;
                    }
            }
        }
        catch(IOException e)
        {
            e.printStackTrace();
        }
    }

    private static String getStartRecipeTypeGroup(IRecipeType<?> type)
    {
        return getName(type).getPath() + "-recipes";
    }

    public static JsonObject singletonJsonObject(String key, String value)
    {
        JsonObject obj = new JsonObject();
        obj.addProperty(key, value);
        return obj;
    }

    public static JsonObject mapToJsonObject(Map<String, Object> map)
    {
        JsonObject obj = new JsonObject();
        map.forEach((s, o) ->
        {
            if(o instanceof Number) obj.addProperty(s, (Number) o);
            else if(o instanceof String) obj.addProperty(s, (String) o);
            else if(o instanceof Boolean) obj.addProperty(s, (Boolean) o);
            else if(o instanceof Character) obj.addProperty(s, (Character) o);
        });
        return obj;
    }

    public static JsonArray listWithSingletonItems(List<Item> items, String key)
    {
        JsonArray array = new JsonArray();
        items.forEach(item -> array.add(singletonJsonObject(key, item.getRegistryName().toString())));
        return array;
    }

    public static void setRecipeType(JsonObject obj, IRecipeType<?> type)
    {
        obj.addProperty("type", getName(type).toString());
    }

    public static ResourceLocation getName(IRecipeType<?> recipeType)
    {
        return Registry.RECIPE_TYPE.getKey(recipeType);
    }

    public static <T extends IRecipe<C>, C extends IInventory> IRecipeType<T> byName(ResourceLocation location)
    {
        return (IRecipeType<T>) Registry.RECIPE_TYPE.getOptional(location).orElse(null);
    }

    public static List<JsonObject> getJsonRecipes(IRecipeType<?> recipeType, String modId)
    {
        List<JsonObject> jsonRecipes = new ArrayList<>();

        try
        {
            File recipeFile = RecipeFileUtils.getRecipeFile(modId);

            checkTypeGroup(recipeFile, recipeType);

            List<String> lines = Files.readAllLines(recipeFile.toPath(), StandardCharsets.UTF_8);

            for(String line : lines)
                if(line.contains(getName(recipeType).toString()) && line.contains("event.custom"))
                {
                    Matcher JSON_MATCHER = RECIPE_PATTERN.matcher(line);

                    if(JSON_MATCHER.find())
                    {
                        JsonObject jsonObject = GSON.fromJson(new StringReader(JSON_MATCHER.group()), JsonObject.class);
                        jsonRecipes.add(jsonObject);
                    }
                }
        }
        catch(IOException ignored)
        {
        }

        return jsonRecipes;
    }

    private static void getModifiedRecipe(ModifiedRecipe modifiedRecipe, String line)
    {
        String title = "";
        List<ITextComponent> list = new ArrayList<>();

        JsonObject json = GSON.fromJson(line, JsonElement.class).getAsJsonObject();

        for(ModRecipesJSSerializer.RecipeDescriptors descriptor : ModRecipesJSSerializer.RecipeDescriptors.values())
        {
            if(json.has(descriptor.getTag()))
            {
                modifiedRecipe.setDescriptor(descriptor, json.get(descriptor.getTag()).getAsString());
            }
        }
    }

    public static PairValue<String, Integer> getParam(IRecipe<?> recipe)
    {
        if(recipe instanceof IManaInfusionRecipe)
            return PairValue.create("Mana", ((IManaInfusionRecipe) recipe).getManaToConsume());
        else if(recipe instanceof IRuneAltarRecipe)
            return PairValue.create("Mana", ((IRuneAltarRecipe) recipe).getManaUsage());
        else if(recipe instanceof ITerraPlateRecipe)
            return PairValue.create("Mana", ((ITerraPlateRecipe) recipe).getMana());
        else if(recipe instanceof IPureDaisyRecipe)
            return PairValue.create("Time", ((IPureDaisyRecipe) recipe).getTime());

        return null;
    }

    public static Map<String, ResourceLocation> getOutput(IRecipe<?> recipe)
    {
        Map<String, ResourceLocation> locations = new HashMap<>();

        if(recipe instanceof IPureDaisyRecipe)
        {
            IPureDaisyRecipe recipePureDaisy = (IPureDaisyRecipe) recipe;
            locations.put("Block", recipePureDaisy.getOutputState().getBlock().getRegistryName());
        }

        if(recipe instanceof IElvenTradeRecipe)
        {
            IElvenTradeRecipe recipeElvenTrade = (IElvenTradeRecipe) recipe;
            recipeElvenTrade.getOutputs().forEach(is -> locations.put("Item", is.getItem().getRegistryName()));
        }

        if(recipe instanceof IBrewRecipe)
        {
            IBrewRecipe recipeBrew = (IBrewRecipe) recipe;
            locations.put("Brew", recipeBrew.getBrew().getRegistryName());
        }

        return !locations.isEmpty() ? locations : Collections.singletonMap("Item", recipe.getRecipeOutput().getItem().getRegistryName());
    }

    @SuppressWarnings("unused")
    public static ItemStack getOneOutput(IRecipe<?> recipe)
    {
        ItemStack stack = new ItemStack(Items.AIR);
        Map<String, ResourceLocation> locations = getOutput(recipe);

        Map.Entry<String, ResourceLocation> entry = locations.entrySet().stream().findFirst().orElse(null);

        switch(entry.getKey())
        {
            case "Block":
                stack = new ItemStack(ForgeRegistries.BLOCKS.getValue(entry.getValue()));
                break;
            case "Item":
                stack = new ItemStack(ForgeRegistries.ITEMS.getValue(entry.getValue()));
                break;
            case "Brew":
                stack = ((ItemVial) ModItems.flask).getItemForBrew(BotaniaAPI.instance().getBrewRegistry().getOrDefault(entry.getValue()), new ItemStack(ModItems.flask));
                break;
        }

        return stack;
    }

    public static Multimap<String, ResourceLocation> getInput(IRecipe<?> recipe)
    {
        Multimap<String, ResourceLocation> locations = ArrayListMultimap.create();

        if(recipe instanceof IPureDaisyRecipe)
        {
            IPureDaisyRecipe recipePureDaisy = (IPureDaisyRecipe) recipe;

            if(recipePureDaisy.getInput() instanceof StateIngredientTag)
                locations.put("Tag", ((StateIngredientTag) recipePureDaisy.getInput()).getTagId());
            else locations.put("Block", recipePureDaisy.getInput().pick(new Random()).getBlock().getRegistryName());
            return locations;
        }

        locations.putAll(getIngredients(recipe.getIngredients()));

        if(locations.isEmpty()) locations.put("Item", recipe.getRecipeOutput().getItem().getRegistryName());

        return locations;
    }

    private static Multimap<String, ResourceLocation> getIngredients(NonNullList<Ingredient> ingredients)
    {
        Multimap<String, ResourceLocation> locations = ArrayListMultimap.create();

        ingredients.forEach(ingredient ->
        {
            JsonElement json = ingredient.serialize();
            if(json instanceof JsonArray) json.getAsJsonArray().forEach(je -> getAndSave(je, locations));
            else getAndSave(json, locations);
        });

        return locations;
    }

    private static void getAndSave(JsonElement element, Multimap<String, ResourceLocation> map)
    {
        if(element.getAsJsonObject().has("item"))
            map.put("Item", ResourceLocation.tryCreate(element.getAsJsonObject().get("item").getAsString()));
        else map.put("Tag", ResourceLocation.tryCreate(element.getAsJsonObject().get("tag").getAsString()));
    }

    public static void removeModifiedRecipe(ModifiedRecipe recipe)
    {
        for(String modId : SupportedMods.MODS_IDS)
        {
            try
            {
                File recipeFile = RecipeFileUtils.getRecipeFile(modId);
                List<String> lines = Files.readAllLines(recipeFile.toPath(), StandardCharsets.UTF_8);

                int index = 0;
                for(String line : lines)
                {
                    String descriptor = recipe.getType().getDescriptor();
                    if(line.contains(descriptor))
                    {
                        Matcher JSON_MATCHER = RECIPE_PATTERN.matcher(line);

                        if(JSON_MATCHER.find())
                        {
                            ModifiedRecipeType modifiedRecipeType = recipe.getType();
                            ModifiedRecipe modifiedRecipe = new ModifiedRecipe(modifiedRecipeType);
                            getModifiedRecipe(modifiedRecipe, JSON_MATCHER.group());

                            if(modifiedRecipe.getRecipeMap().equals(recipe.getRecipeMap()))
                            {
                                lines.remove(index);
                                Files.write(recipeFile.toPath(), lines, StandardCharsets.UTF_8);
                                return;
                            }
                        }
                    }
                    index++;
                }
            }
            catch(IOException e)
            {
                e.printStackTrace();
            }
        }
    }

    public static boolean isModifiedRecipePresent(ModifiedRecipe recipe)
    {
        for(String modId : SupportedMods.MODS_IDS)
        {
            try
            {
                File recipeFile = RecipeFileUtils.getRecipeFile(modId);
                List<String> lines = Files.readAllLines(recipeFile.toPath(), StandardCharsets.UTF_8);

                int index = 0;
                for(String line : lines)
                {
                    String descriptor = recipe.getType().getDescriptor();

                    if(!line.contains(descriptor)) continue;

                    Matcher JSON_MATCHER = RECIPE_PATTERN.matcher(line);

                    if(JSON_MATCHER.find())
                    {
                        ModifiedRecipeType modifiedRecipeType = recipe.getType();
                        ModifiedRecipe modifiedRecipe = new ModifiedRecipe(modifiedRecipeType);
                        getModifiedRecipe(modifiedRecipe, JSON_MATCHER.group());

                        if(modifiedRecipe.getRecipeMap().equals(recipe.getRecipeMap()))
                        {
                            return true;
                        }
                    }
                    index++;
                }
            }
            catch(IOException e)
            {
                e.printStackTrace();
            }
        }

        return false;
    }

    public enum ModifiedRecipeType
    {
        REMOVED("event.remove", new StringTextComponent("Removed").mergeStyle(TextFormatting.RED)), REPLACED_INPUT("event.replaceInput", new StringTextComponent("Input Replaced").mergeStyle(TextFormatting.GOLD)), REPLACED_OUTPUT("event.replaceOutput", new StringTextComponent("Output Replaced").mergeStyle(TextFormatting.YELLOW));

        private final String descriptor;
        private final ITextComponent title;

        ModifiedRecipeType(String descriptor, ITextComponent title)
        {
            this.descriptor = descriptor;
            this.title = title;
        }

        public String getDescriptor()
        {
            return descriptor;
        }

        public static ModifiedRecipeType byDescriptor(String descriptor)
        {
            for(ModifiedRecipeType type : ModifiedRecipeType.values())
            {
                if(type.getDescriptor().equals(descriptor)) return type;
            }

            return null;
        }

        public ITextComponent getTitle()
        {
            return title;
        }
    }
}
